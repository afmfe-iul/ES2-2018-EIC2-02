package main.optimization.platform.gui.external;

import java.awt.Container;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.net.CookieHandler;
import java.net.CookieManager;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Scanner;
import javax.swing.JFrame;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.HBox;
import org.apache.commons.io.FileUtils;
import javafx.application.Platform;
import javafx.embed.swing.JFXPanel;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.control.Button;
import javafx.scene.Scene;
import javafx.scene.web.WebEngine;
import javafx.scene.web.WebView;
import main.optimization.platform.utils.Builders;

/**
 * 
 * @author André Freire
 *
 */
@SuppressWarnings("restriction")
public class DataVisualization extends JFXPanel {
	private static final long serialVersionUID = 1L;
	private static int VERSION = 0;
	private boolean dataFileBuiltSuccessfuly = false;
	private String buildErrorMessage;
	private Button btnBack;
	private Button btnReload;
	private WebEngine webEngine;

	/**
	 * Constructor method.
	 * @param algorithmsNames	The names of the algorithms to visualize
	 * @param rsFilePaths		The paths to the .rs files generated by jMetal
	 * @param rfFilePaths		The paths to the .rf files generated by JMetal
	 * @param decisionVariables	The names given to the variables of the Problem
	 * @param knownSolution		A Solution known by the user. This value corresponds to the sum of all optimization criterias given by the user
	 */
	public DataVisualization(List<String> algorithmsNames, List<String> rsFilePaths, List<String> rfFilePaths,
			List<String> decisionVariables, Integer knownSolution) {
		Collections.sort(algorithmsNames);
		if (algorithmsNames.size() != rfFilePaths.size() || algorithmsNames.size() == 0 || rfFilePaths.size() == 0) {
			dataFileBuiltSuccessfuly = false;
			buildErrorMessage = "There is a problem with .rs and .rf files, rerun the problem.";
		} else {
			VERSION++;
			String rsFirstLine = null;
			String[] rsLines = null;
			if (rsFilePaths.size() > 0) {
				rsFirstLine = "variable";
				rsLines = new String[decisionVariables.size()];
				for (int i = 0; i < rsLines.length; i++) {
					rsLines[i] = decisionVariables.get(i);
				}
			}

			String rfFirstLine = "User Solution";
			String rfSecondLine = knownSolution == null ? "-1" : String.valueOf(knownSolution);

			// logic to read .rs file
			try {
				for (int i = 0; i < rsFilePaths.size(); i++) {
					Scanner rsScanner = new Scanner(new File(rsFilePaths.get(i)));
					int differentRunsOfTheSameAlgorithm = 0;

					while (rsScanner.hasNextLine()) {
						String thisRunName = algorithmsNames.get(i) + "(" + differentRunsOfTheSameAlgorithm + ")";
						rsFirstLine += "\t" + thisRunName;
						String[] weights = rsScanner.nextLine().split(" ");
						if (weights.length != decisionVariables.size()) {
							dataFileBuiltSuccessfuly = false;
							buildErrorMessage = "The Problem format seems to have an error.";
							rsScanner.close();
							return;
						}

						for (int j = 0; j < weights.length; j++) {
							rsLines[j] += "\t" + weights[j];
						}
						differentRunsOfTheSameAlgorithm++;
					}
					rsScanner.close();
				}

				// logic to read .rf file
				for (int i = 0; i < rfFilePaths.size(); i++) {
					Scanner rfScanner = new Scanner(new File(rfFilePaths.get(i)));

					int differentRunsOfTheSameAlgorithm = 0;
					while (rfScanner.hasNextLine()) {
						String thisRunName = algorithmsNames.get(i) + "(" + differentRunsOfTheSameAlgorithm + ")";
						rfFirstLine += "\t" + thisRunName;
						rfSecondLine += ("\t" + calculateRfFileResult(rfScanner.nextLine().split(" ")));

						differentRunsOfTheSameAlgorithm++;
					}
					rfScanner.close();
				}
			} catch (FileNotFoundException e) {
				dataFileBuiltSuccessfuly = false;
				buildErrorMessage = "The Problem results are not ready to display yet, or the foler where they were written to was deleted.";
				e.printStackTrace();
				return;
			}
			writeVisualizationFiles(rsFirstLine, rsLines, rfFirstLine, rfSecondLine);
		}
	}

	/**
	 * This method will attempt to start a JFXPanel to show a html page, if it succeeds it will return true, and false otherwise.
	 * @return <b>true</b> if all the files required for the visualizations are found and correct.<br>
	 * 			<b>false</b> otherwise.
	 */
	public boolean run() {
		if (dataFileBuiltSuccessfuly) {
			String tempDir = Builders.BASE_DIRECTORY + "visualizations/temp" + VERSION;
			File f = new File(tempDir + "/graphics.html");
			try {
				setName("Results Visualization");
				BorderPane root = new BorderPane();
				root.setTop(getButtonPanel());

				URL url = f.toURI().toURL();
				Platform.runLater(() -> {
					CookieHandler.setDefault(new CookieManager());
					WebView webView = new WebView();
					root.setCenter(webView);
					setScene(new Scene(root));
					webEngine = webView.getEngine();
					webEngine.load(url.toString());
				});
			} catch (MalformedURLException e) {
				e.printStackTrace();
			}
		}
		return dataFileBuiltSuccessfuly;
	}

	/**
	 * This method returns the sum of all the values in a line of an .rf file.
	 * @param 	rfFileLine the line from an .rf file
	 * @return 	A String with the sum of all the values in that .rf line
	 */
	private String calculateRfFileResult(String[] rfFileLine) {
		int result = 0;
		for (int i = 0; i < rfFileLine.length; i++) {
			result += Double.valueOf(rfFileLine[i]);
		}
		return String.valueOf(result);
	}

	/**
	 * This method writes temporary files to feed as input to the D3js (javascript) framework.
	 * @param rsFirstLine 	the first line taken from the .rs file and formatted accordingly to pass to D3js
	 * @param rsLines		all the following lines taken from the .rs file and formatted accordingly to pass to D3js
	 * @param rfFirstLine	the first line taken from the .rf file and formatted accordingly to pass to D3js
	 * @param rfSecondLine	all the following lines taken from the .rf file and formatted accordingly to pass to D3js
	 */
	private void writeVisualizationFiles(String rsFirstLine, String[] rsLines, String rfFirstLine,
			String rfSecondLine) {
		try {
			deleteDirectory(new File(Builders.BASE_DIRECTORY + "visualizations"));
			String tempDir = Builders.BASE_DIRECTORY + "visualizations/temp" + VERSION;
			InputStream inputStream = this.getClass().getResourceAsStream("/template.html");

			FileUtils.copyInputStreamToFile(inputStream, new File(tempDir + "/graphics.html"));
			PrintWriter writer;

			// Write the data file in tsv format (tab separated values)
			if (rsFirstLine != null && rsLines != null) {
				writer = new PrintWriter(tempDir + "/data.tsv");
				writer.println(rsFirstLine);
				for (int i = 0; i < rsLines.length; i++) {
					writer.println(rsLines[i]);
				}
				writer.close();
			}

			// Write an auxiliar file so that javascript knows the algorithm names
			// and use them to loop over map values.
			if (rsFirstLine != null) {
				writer = new PrintWriter(tempDir + "/auxiliar.tsv");
				String header = new String();
				for (int i = 0; i < rsFirstLine.split("\t").length - 1; i++) {
					header += "\t" + "algorithm" + i;
				}
				writer.println(header.trim());
				writer.println(rsFirstLine.substring("variable".length()).trim());
				writer.close();
			}

			// Write an auxiliar file to be used by D3.js, where the rf file results are
			// stored
			writer = new PrintWriter(tempDir + "/auxRf.tsv");

			// orders the results before saving to a file
			String[] algoName = rfFirstLine.split("\t");
			int[] algoResults = Arrays.asList(rfSecondLine.split("\t")).stream().mapToInt(Integer::parseInt).toArray();
			HashMap<Integer, String> resultToAlgoMap = new HashMap<>();
			for (int i = 0; i < algoName.length; i++) {
				if (resultToAlgoMap.containsKey(algoResults[i])) {
					resultToAlgoMap.put(algoResults[i], resultToAlgoMap.get(algoResults[i]) + "\t" + algoName[i]);
				} else {
					resultToAlgoMap.put(algoResults[i], algoName[i]);
				}
			}

			Arrays.sort(algoResults);
			writer.println("Algorithm\tResult");
			for (int i = 0; i < algoResults.length; i++) {
				String[] s = resultToAlgoMap.get(algoResults[i]).split("\t");
				if (s.length > 1) {
					String[] s2 = resultToAlgoMap.get(algoResults[i]).split("\t", 2);
					resultToAlgoMap.put(algoResults[i], s2[1]);
				}
				writer.println((s[0] + "\t" + algoResults[i]).trim());
			}
			writer.close();
			dataFileBuiltSuccessfuly = true;
			Platform.setImplicitExit(false);
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	/**
	 * This method deletes directories recursevily because Java doesn't allow to delete non-empty folders
	 * @param dir	the root directory to be deleted.
	 * @return		<b>true</b> if and only if the file or directory is successfully deleted.<br>
	 * 				<b>false</b> otherwise
	 */
	private boolean deleteDirectory(File dir) {
		File[] files = dir.listFiles();
		if (files != null) {
			for (int i = 0; i < files.length; i++) {
				deleteDirectory(files[i]);
			}
		}
		if (dir.getName().equals("template.html")) {
			return true;
		} else {
			return dir.delete();
		}
	}

	/**
	 * This method adds an action listener to the Back button of the Visualization frame, to allow the user to return to the main frame.
	 * @param frame		the main frame of the application to where the user can return.
	 * @param mainPanel	the main container from the main frame.
	 */
	public void addBackButtonActionListener(JFrame frame, Container mainPanel) {
		DataVisualization dv = this;
		btnBack.setOnAction(new EventHandler<ActionEvent>() {
			@Override
			public void handle(ActionEvent event) {
				frame.remove(dv);
				frame.setContentPane(mainPanel);
				frame.revalidate();
				frame.repaint();
				frame.setBounds(320, 30, 1000, 667);
			}
		});
	}

	/**
	 * 
	 * @return A string with an error message informing what went wrong while trying to build the D3js visualizations.
	 */
	public String getBuildErrorMessage() {
		return buildErrorMessage;
	}

	/**
	 * 
	 * @return An HBox object containing all buttons necessary to navigate from to main frame to the Visualization frame and to refresh the
	 * 			visualizations page.
	 */
	private HBox getButtonPanel() {
		HBox hbox = new HBox();
		hbox.setPadding(new Insets(5, 0, 5, 0));
		hbox.setSpacing(100);
		hbox.setStyle("-fx-background-color: #336699;");
		hbox.setAlignment(Pos.CENTER);

		btnBack = new Button("Go Back");
		btnBack.setStyle("-fx-font: 22 arial; -fx-font-weight: bold;");
		btnBack.setPrefSize(200, 30);
		btnReload = new Button("Reload Frame");
		btnReload.setStyle("-fx-font: 22 arial; -fx-font-weight: bold;");
		btnReload.setPrefSize(200, 30);
		btnReload.setOnAction(new EventHandler<ActionEvent>() {
			@Override
			public void handle(ActionEvent event) {
				webEngine.reload();
			}
		});

		hbox.getChildren().addAll(btnBack, btnReload);
		return hbox;
	}
}